package pbrpc

import (
	"context"
	"errors"
	"io"
	"io/ioutil"
	"log"
	"reflect"
	"strings"
	"sync"

	"github.com/golang/protobuf/proto"
	"google.golang.org/grpc"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/encoding"
	"google.golang.org/grpc/metadata"

	pb "github.com/azcorp-cloud/pbrpc/rpc"
	"unsafe"
)

// ErrStreamClosed returns when read-write from-to closed stream
var ErrStreamClosed = errors.New("stream is no longer exist")

// Serial interface for all protobuf structures generated by gofast
type Serial interface {
	proto.Marshaler
	proto.Unmarshaler
}

// NewServer extract service and method with reflection from grpc server and create Server struct
func NewServer(grpcServer *grpc.Server) *Server {
	server := &Server{
		m:     make(map[string]*Service),
		mu:    new(sync.RWMutex),
		codec: encoding.GetCodec("proto"),
	}
	serviceMap := mustGetUnexportedFieldByName("m", grpcServer)
	serviceMapReflect := reflect.ValueOf(serviceMap)
	for _, serviceKey := range serviceMapReflect.MapKeys() {
		serviceReflect := serviceMapReflect.MapIndex(serviceKey)
		srv := mustGetUnexportedFieldByName("server", serviceReflect.Interface())
		service := Service{
			Server:     srv,
			MethodDesk: make(map[string]*grpc.MethodDesc),
			StreamDesk: make(map[string]*grpc.StreamDesc),
		}
		md := mustGetUnexportedFieldByName("md", serviceReflect.Interface())
		methodMapReflect := reflect.ValueOf(md)
		for _, methodKey := range methodMapReflect.MapKeys() {
			methodReflect := methodMapReflect.MapIndex(methodKey)
			md, ok := methodReflect.Interface().(*grpc.MethodDesc)
			if ok {
				service.MethodDesk[methodKey.String()] = md
			}
		}
		sd := mustGetUnexportedFieldByName("sd", serviceReflect.Interface())
		streamMapReflect := reflect.ValueOf(sd)
		for _, streamKey := range streamMapReflect.MapKeys() {
			streamReflect := streamMapReflect.MapIndex(streamKey)
			sd, ok := streamReflect.Interface().(*grpc.StreamDesc)
			if ok {
				service.StreamDesk[streamKey.String()] = sd
			}
		}
		servicePath := strings.Split(serviceKey.String(), ".")
		if len(servicePath) > 0 {
			log.Printf("Register Service %s", servicePath[1])
			server.m[servicePath[1]] = &service
		} else {
			panic("bad Service path")
		}
	}
	return server
}

// Service contains information of the Server serving this Service and
// the methods in this Service.
type Service struct {
	Server     interface{} // the Server for Service methods
	MethodDesk map[string]*grpc.MethodDesc
	StreamDesk map[string]*grpc.StreamDesc
}

// Server hold Service and its Method maps
type Server struct {
	codec encoding.Codec
	mu    *sync.RWMutex
	m     map[string]*Service // Service name -> Service info
}

// ServeConnCtx create to threads for startRead and write in connection
func (s *Server) ServeConnCtx(ctx context.Context, conn io.ReadWriteCloser) error {
	connection := serverConn{
		s:       s,
		ctx:     ctx,
		lock:    new(sync.Mutex),
		conn:    conn,
		streams: make(map[uint64]*Stream),
		codec:   s.codec,
	}
	return connection.startRead()
}

// Stream reserved id namespace. All messages in it has same id
type Stream struct {
	id       uint64
	method   string
	ctx      context.Context
	sc       *serverConn
	isOpen   bool
	readChan chan *pb.Message
	cancel   func()
}

// SetHeader make Stream be assignable to grpc.ServerStream
func (s *Stream) SetHeader(metadata.MD) error {
	panic("implement me")
}

// SendHeader make Stream be assignable to grpc.ServerStream
func (s *Stream) SendHeader(metadata.MD) error {
	panic("implement me")
}

// SetTrailer make Stream be assignable to grpc.ServerStream
func (s *Stream) SetTrailer(metadata.MD) {
	panic("implement me")
}

// Context return context of Stream
func (s *Stream) Context() context.Context {
	return s.ctx
}

// SendMsg write response message with same stream id
func (s *Stream) SendMsg(m interface{}) error {
	if s != nil {
		select {
		case <-s.ctx.Done():
			return s.ctx.Err()
		default:
			replyData, err := s.sc.codec.Marshal(m)
			if err != nil {
				return err
			}
			return s.sc.writeResponse(&pb.Message{
				InStream: true,
				Id:       s.id,
				Reply:    replyData,
				Method:   s.method,
			})
		}
	} else {
		return ErrStreamClosed
	}
}

// RecvMsg wait for messages in Stream channel
func (s *Stream) RecvMsg(m interface{}) error {
	if s != nil {
		select {
		case <-s.ctx.Done():
			return s.ctx.Err()
		case req, ok := <-s.readChan:
			if ok {
				err := s.sc.codec.Unmarshal(req.Arg, m)
				if err != nil {
					return err
				}
				return nil
			}
			return ErrStreamClosed
		}
	} else {
		return ErrStreamClosed
	}

}

type serverConn struct {
	s       *Server
	ctx     context.Context
	lock    *sync.Mutex
	conn    io.ReadWriteCloser
	codec   encoding.Codec
	streams map[uint64]*Stream
}

func (sc *serverConn) writeResponse(serial proto.Marshaler) error {
	respData, err := serial.Marshal()
	if err != nil {
		return err
	}
	sc.lock.Lock()
	_, err = sc.conn.Write(respData)
	sc.lock.Unlock()
	return err
}

func (sc *serverConn) readRequest(serial proto.Unmarshaler) error {
	data, err := ioutil.ReadAll(sc.conn)
	if err != nil {
		return err
	}
	return serial.Unmarshal(data)
}

func (sc *serverConn) handleRequest(request *pb.Message) error {
	serviceAndMethod := strings.Split(request.Method, ".")
	serviceName := serviceAndMethod[0]
	methodName := serviceAndMethod[1]
	service, ok := sc.s.m[serviceName]
	if !ok {
		return sc.writeResponse(&pb.Message{
			Id:     request.Id,
			Method: request.Method,
			Error: &pb.Error{
				Code:    int32(codes.Unimplemented),
				Message: "no such service",
			},
		})
	}
	decodeFunc := func(v interface{}) error {
		return sc.s.codec.Unmarshal(request.Arg, v)
	}
	unaryMethod, ok := service.MethodDesk[methodName]
	if ok {
		reply, appErr := unaryMethod.Handler(service.Server, sc.ctx, decodeFunc, nil)
		return sc.sendReply(request, reply, appErr)
	}
	streamMethod, ok := service.StreamDesk[methodName]
	if ok {
		streamCtx, cancel := context.WithCancel(sc.ctx)
		stream := &Stream{
			readChan: make(chan *pb.Message, 1000),
			method:   request.Method,
			id:       request.Id,
			sc:       sc,
			isOpen:   true,
			ctx:      streamCtx,
			cancel:   cancel,
		}
		sc.streams[stream.id] = stream
		defer func() {
			stream.cancel()
			delete(sc.streams, stream.id)
		}()
		stream.readChan <- request
		appErr := streamMethod.Handler(service.Server, stream)
		resp := &pb.Message{
			Id:       request.Id,
			Method:   request.Method,
			InStream: false,
		}
		if appErr != nil {
			resp.Error = &pb.Error{
				Code:    int32(codes.Internal),
				Message: appErr.Error(),
			}
		}
		return sc.writeResponse(resp)
	}
	return sc.writeResponse(&pb.Message{
		Id:     request.Id,
		Method: request.Method,
		Error: &pb.Error{
			Code:    int32(codes.Unimplemented),
			Message: "no such method",
		},
	})
}

func (sc *serverConn) sendReply(request *pb.Message, reply interface{}, appErr error) error {
	resp := pb.Message{
		Method: request.Method,
		Id:     request.Id,
	}
	if reply != nil {
		replyData, err := sc.s.codec.Marshal(reply)
		if err != nil {
			return sc.writeResponse(&pb.Message{
				Id:     request.Id,
				Method: request.Method,
				Error: &pb.Error{
					Code:    int32(codes.Internal),
					Message: "can`t marshal reply",
				},
			})
		}
		resp.Reply = replyData
	}
	if appErr != nil {
		resp.Error = &pb.Error{
			Code:    int32(codes.Internal),
			Message: appErr.Error(),
		}
	}
	return sc.writeResponse(&resp)
}

func (sc *serverConn) startRead() error {
	for {
		select {
		case <-sc.ctx.Done():
			return sc.ctx.Err()
		default:
			req := new(pb.Message)
			err := sc.readRequest(req)
			if err != nil {
				return err
			}
			if len(sc.streams) > 0 {
				stream, ok := sc.streams[req.Id]
				if ok {
					if req.InStream {
						stream.readChan <- req
					} else {
						stream.cancel()
					}
					continue
				}
			}
			go func() {
				err = sc.handleRequest(req)
				if err != nil {
					log.Print(err)
				}
			}()
		}
	}
}

// MustGetUnexportedFieldByName extract value from given struct even if it is unexported.
// x must be pointer on struct not value. Panic on errors.
func mustGetUnexportedFieldByName(name string, x interface{}) interface{} {
	xReflection := reflect.ValueOf(x).Elem()
	fieldReflection := xReflection.FieldByName(name)
	return reflect.NewAt(fieldReflection.Type(), unsafe.Pointer(fieldReflection.UnsafeAddr())).Elem().Interface()
}
